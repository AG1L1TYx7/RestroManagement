const { pool } = require('../config/database');

class Order {
    /**
     * Create a new order
     * @param {Object} orderData - Order information
     * @returns {Object} Created order with ID
     */
    static async create(orderData) {
        const connection = await pool.getConnection();
        try {
            await connection.beginTransaction();

            const {
                created_by,
                table_id,
                order_type = 'dine-in',
                payment_method = 'cash',
                special_instructions = null,
                discount_amount = 0,
                tax_amount = 0
            } = orderData;

            // Calculate initial totals (will be updated when items are added)
            const subtotal = 0;
            const total = subtotal - discount_amount + tax_amount;

            const [result] = await connection.query(
                `INSERT INTO orders 
                (created_by, table_id, order_type, status, payment_method, 
                 payment_status, subtotal, discount_amount, tax_amount, total, 
                 special_instructions, created_at, updated_at)
                VALUES (?, ?, ?, 'pending', ?, 'unpaid', ?, ?, ?, ?, ?, NOW(), NOW())`,
                [created_by, table_id, order_type, payment_method, 
                 subtotal, discount_amount, tax_amount, total, special_instructions]
            );

            await connection.commit();

            return {
                order_id: result.insertId,
                created_by,
                table_id,
                order_type,
                status: 'pending',
                payment_method,
                payment_status: 'unpaid',
                subtotal,
                discount_amount,
                tax_amount,
                total,
                special_instructions
            };
        } catch (error) {
            await connection.rollback();
            throw error;
        } finally {
            connection.release();
        }
    }

    /**
     * Find order by ID with customer and item details
     * @param {number} orderId - Order ID
     * @returns {Object|null} Order details or null
     */
    static async findById(orderId) {
        const connection = await pool.getConnection();
        try {
            const [orders] = await connection.query(
                `SELECT o.*, 
                        u.username as customer_username,
                        u.full_name as customer_name,
                        u.email as customer_email,
                        u.phone as customer_phone
                 FROM orders o
                 LEFT JOIN users u ON o.created_by = u.user_id
                 WHERE o.order_id = ? AND o.`,
                [orderId]
            );

            if (orders.length === 0) {
                return null;
            }

            const order = orders[0];

            // Get order items
            const [items] = await connection.query(
                `SELECT oi.*, 
                        m.name as item_name,
                        m.image_url,
                        c.name as category_name
                 FROM order_items oi
                 JOIN menu_items m ON oi.item_id = m.item_id
                 JOIN categories c ON m.category_id = c.category_id
                 WHERE oi.order_id = ?
                 ORDER BY oi.order_item_id ASC`,
                [orderId]
            );

            order.items = items;
            order.items_count = items.length;

            return order;
        } finally {
            connection.release();
        }
    }

    /**
     * Find all orders with filtering options
     * @param {Object} filters - Filter options
     * @returns {Array} Array of orders
     */
    static async findAll(filters = {}) {
        const connection = await pool.getConnection();
        try {
            const {
                created_by,
                status,
                payment_status,
                order_type,
                from_date,
                to_date,
                limit = 50,
                offset = 0
            } = filters;

            let query = `
                SELECT o.*, 
                       u.username as customer_username,
                       u.full_name as customer_name,
                       COUNT(oi.order_item_id) as items_count
                FROM orders o
                LEFT JOIN users u ON o.created_by = u.user_id
                LEFT JOIN order_items oi ON o.order_id = oi.order_id
                WHERE o.
            `;

            const params = [];

            if (created_by) {
                query += ' AND o.created_by = ?';
                params.push(created_by);
            }

            if (status) {
                query += ' AND o.status = ?';
                params.push(status);
            }

            if (payment_status) {
                query += ' AND o.payment_status = ?';
                params.push(payment_status);
            }

            if (order_type) {
                query += ' AND o.order_type = ?';
                params.push(order_type);
            }

            if (from_date) {
                query += ' AND DATE(o.created_at) >= ?';
                params.push(from_date);
            }

            if (to_date) {
                query += ' AND DATE(o.created_at) <= ?';
                params.push(to_date);
            }

            query += ' GROUP BY o.order_id';
            query += ' ORDER BY o.created_at DESC';
            query += ' LIMIT ? OFFSET ?';
            params.push(parseInt(limit), parseInt(offset));

            const [orders] = await connection.query(query, params);

            return orders;
        } finally {
            connection.release();
        }
    }

    /**
     * Update order status
     * @param {number} orderId - Order ID
     * @param {string} newStatus - New status
     * @param {number} updatedBy - User ID making the update
     * @returns {Object} Updated order
     */
    static async updateStatus(orderId, newStatus, updatedBy = null) {
        const connection = await pool.getConnection();
        try {
            const validStatuses = ['pending', 'confirmed', 'preparing', 'ready', 'served', 'completed', 'cancelled'];
            
            if (!validStatuses.includes(newStatus)) {
                throw new Error(`Invalid status: ${newStatus}`);
            }

            const updateFields = ['status = ?', 'updated_at = NOW()'];
            const params = [newStatus];

            // Set timestamps for specific statuses
            if (newStatus === 'confirmed' || newStatus === 'preparing') {
                updateFields.push('confirmed_at = COALESCE(confirmed_at, NOW())');
            }
            if (newStatus === 'preparing') {
                updateFields.push('preparing_at = COALESCE(preparing_at, NOW())');
            }
            if (newStatus === 'ready') {
                updateFields.push('ready_at = COALESCE(ready_at, NOW())');
            }
            if (newStatus === 'served') {
                updateFields.push('served_at = COALESCE(served_at, NOW())');
            }
            if (newStatus === 'completed') {
                updateFields.push('completed_at = COALESCE(completed_at, NOW())');
            }
            if (newStatus === 'cancelled') {
                updateFields.push('cancelled_at = COALESCE(cancelled_at, NOW())');
            }

            params.push(orderId);

            await connection.query(
                `UPDATE orders SET ${updateFields.join(', ')} WHERE order_id = ?`,
                params
            );

            return await this.findById(orderId);
        } finally {
            connection.release();
        }
    }

    /**
     * Update payment status
     * @param {number} orderId - Order ID
     * @param {string} paymentStatus - Payment status
     * @returns {Object} Updated order
     */
    static async updatePaymentStatus(orderId, paymentStatus) {
        const connection = await pool.getConnection();
        try {
            const validPaymentStatuses = ['unpaid', 'paid', 'refunded', 'failed'];
            
            if (!validPaymentStatuses.includes(paymentStatus)) {
                throw new Error(`Invalid payment status: ${paymentStatus}`);
            }

            const updateFields = ['payment_status = ?', 'updated_at = NOW()'];
            const params = [paymentStatus];

            if (paymentStatus === 'paid') {
                updateFields.push('paid_at = COALESCE(paid_at, NOW())');
            }

            params.push(orderId);

            await connection.query(
                `UPDATE orders SET ${updateFields.join(', ')} WHERE order_id = ?`,
                params
            );

            return await this.findById(orderId);
        } finally {
            connection.release();
        }
    }

    /**
     * Update order totals after items are added/removed
     * @param {number} orderId - Order ID
     * @returns {Object} Updated order
     */
    static async updateTotals(orderId) {
        const connection = await pool.getConnection();
        try {
            // Calculate subtotal from order items
            const [result] = await connection.query(
                `SELECT COALESCE(SUM(quantity * price), 0) as subtotal
                 FROM order_items
                 WHERE order_id = ?`,
                [orderId]
            );

            const subtotal = parseFloat(result[0].subtotal);

            // Get current discount and tax
            const [order] = await connection.query(
                'SELECT discount_amount, tax_amount FROM orders WHERE order_id = ?',
                [orderId]
            );

            const discount = parseFloat(order[0].discount_amount);
            const tax = parseFloat(order[0].tax_amount);
            const total = subtotal - discount + tax;

            await connection.query(
                `UPDATE orders 
                 SET subtotal = ?, total = ?, updated_at = NOW()
                 WHERE order_id = ?`,
                [subtotal, total, orderId]
            );

            return await this.findById(orderId);
        } finally {
            connection.release();
        }
    }

    /**
     * Delete order (soft delete)
     * @param {number} orderId - Order ID
     * @returns {boolean} Success status
     */
    static async delete(orderId) {
        const connection = await pool.getConnection();
        try {
            await connection.query(
                'UPDATE orders SET is_deleted = 1, updated_at = NOW() WHERE order_id = ?',
                [orderId]
            );
            return true;
        } finally {
            connection.release();
        }
    }

    /**
     * Get order statistics
     * @param {Object} filters - Date filters
     * @returns {Object} Statistics
     */
    static async getStatistics(filters = {}) {
        const connection = await pool.getConnection();
        try {
            const { from_date, to_date } = filters;
            let query = 'SELECT ';
            query += 'COUNT(*) as total_orders, ';
            query += 'SUM(CASE WHEN status = "completed" THEN 1 ELSE 0 END) as completed_orders, ';
            query += 'SUM(CASE WHEN status = "cancelled" THEN 1 ELSE 0 END) as cancelled_orders, ';
            query += 'SUM(CASE WHEN payment_status = "paid" THEN total ELSE 0 END) as total_revenue, ';
            query += 'AVG(CASE WHEN payment_status = "paid" THEN total ELSE NULL END) as avg_order_value ';
            query += 'FROM orders WHERE ';

            const params = [];

            if (from_date) {
                query += ' AND DATE(created_at) >= ?';
                params.push(from_date);
            }

            if (to_date) {
                query += ' AND DATE(created_at) <= ?';
                params.push(to_date);
            }

            const [stats] = await connection.query(query, params);

            return stats[0];
        } finally {
            connection.release();
        }
    }

    /**
     * Get orders by status (for kitchen display)
     * @param {Array} statuses - Array of statuses
     * @returns {Array} Orders
     */
    static async findByStatuses(statuses) {
        const connection = await pool.getConnection();
        try {
            const placeholders = statuses.map(() => '?').join(',');
            
            const [orders] = await connection.query(
                `SELECT o.*, 
                        u.full_name as customer_name,
                        COUNT(oi.order_item_id) as items_count,
                        TIMESTAMPDIFF(MINUTE, o.created_at, NOW()) as minutes_waiting
                 FROM orders o
                 LEFT JOIN users u ON o.created_by = u.user_id
                 LEFT JOIN order_items oi ON o.order_id = oi.order_id
                 WHERE o.status IN (${placeholders}) AND o.
                 GROUP BY o.order_id
                 ORDER BY o.created_at ASC`,
                statuses
            );

            return orders;
        } finally {
            connection.release();
        }
    }
}

module.exports = Order;
